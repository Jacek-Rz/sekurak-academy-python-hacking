#!/usr/bin/python3
import pyDes
import math
import sys

# Artykul: https://www.linkedin.com/pulse/why-you-shouldnt-roll-your-own-cryptography-real-life-case

# Funkcja zamieniająca GUID (Microsoftowy odpowiednik UUIDv4) na bajty
# Np. a5b440d3-ec2c-4da3-b85f-a6bd10033ac8 to będzie d340b4a5 2cec a34d b85f a6bd10033ac8
# Zauważ, że pierwsze trzy segmenty GUID'a są zamieniane w odwrotnej kolejności bajtów
def guid2bytes(guid : str):
    sections = guid.split("-")
    result = b""
    for i in range(len(sections) - 2):
        result += bytes.fromhex(sections[i])[::-1]
    for i in range(len(sections) - 2, len(sections)):
        result += bytes.fromhex(sections[i])
    return result

# Ta funkcja zamienia podany ciąg bajtów w argumencie data, na bloki o długiści *size*
# Funkcja zwraca listę bloków, a każdy blok ma postać bajtów (bytes)
def split2blocks(data : bytes, size):
    parts = math.floor(len(data) / size)
    result = []
    for i in range(parts):
        result.append(data[size*i:size*(i+1)])
    leftovers = len(data) - (parts * size)
    if leftovers > 0:
        result.append(data[-leftovers:])
    return result[::-1]

# Funkcja xor wykorzystuje wbudowaną funkcję *zip*, która zwraca listę krotek
# W ten sposób równomiernie przechodzimy w pętli przez listę var oraz key
def xor(var, key):
    return bytes(a ^ b for a, b in zip(var, key))

if len(sys.argv) < 4:
    print(f"Usage: {sys.argv[0]} [company_id] [user_id] [hash]")
    exit()

print(f"[+] Initialization...")
iv = b"\x00\x00\x00\x00\x00\x00\x00\x00"
key =  b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18"

# Inicjalizacja biblioteki pyDes
tripledes = pyDes.triple_des(key, pyDes.CBC, iv, pad=b"\x00")

# Parsowanie argumentów
company_id = guid2bytes(sys.argv[1])
user_id = guid2bytes(sys.argv[2])
hash = bytearray.fromhex(sys.argv[3])

# Tworzenie docelowego tekst jawnego, który oczekujemy otrzymać pod odszyfrowaniu
target_cleartext = b"A"*8 + user_id
# Podzielenie naszego tekstu jawnego na bloki o długości 8 bajtów (długość bloku TripleDES)
cleartext_blocks = split2blocks(target_cleartext, 8)

# Zmienna do zapisu dotychczasowo odzyskanego szyfrogramu
recoverd_ciphertext = hash
current_block = hash

# Przechodzimy w pętli po wszystkich oczekiwanych blokach tekstu jawnego, poza ostatnim
for cleartext_block in cleartext_blocks[:-1]:
    # odszyfrowanie obecnie przetwarzanego bloku
    block = tripledes.decrypt(current_block)
    # Wykonanie operacji xor na odszyfrowanym bloku i oczekiwanym tekście jawnym
    # w ten sposób odzyskujemy poprzedni blok względem obecnego
    previous_block = xor(block, cleartext_block)

    # Zapisujemy wyniki i przechodzimy do następnego
    current_block = previous_block
    recoverd_ciphertext = current_block + recoverd_ciphertext

# Do odzyskanego szyfrogramu doklejamy zaszyfrowane company_id
ciphertext = tripledes.encrypt(company_id) + recoverd_ciphertext

# Odszyfrowujemy otrzymany szyfrogram
cleartext = tripledes.decrypt(ciphertext)

# Wyświetlamy odzyskane hasło :)
print(cleartext[16:24].decode("utf-8"))